# SandyMullican_ITSE2359_Week10
For this project, I represented the maze as a 2D array where cells could be open, walls, or part of the solution path. The recursive solver function searched for a path from start to end, using base cases to prevent the function from wandering out of bounds or revisiting cells, which kept it from looping endlessly. Backtracking was key here, as it let the function "unmark" cells that didn’t lead anywhere useful, ensuring a clean solution path. For visualization, I created a function to display the maze with clear symbols for walls, open spaces, and the path itself. I also added extra flexibility by letting users define custom start and end points and even set up their own maze configurations. One of the trickiest parts was handling boundaries and making sure the backtracking logic was just right—along with managing dynamic inputs for the maze, which required careful checks. Overall, this project gave me a great hands-on dive into recursion, backtracking, and handling real-time input in C++.
